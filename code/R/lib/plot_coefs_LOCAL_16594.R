# Script to grab all the individually saved dataset fits (generated by 'fit_all_datasets.R') from a specified directory and return them as a bundled list object for subsequent profiling and plotting
bundle_fits <- function(dir){
  fits <- list.files(dir, 
                     pattern='.Rdata',
                     full.names=TRUE, 
                     include.dirs=FALSE)
  bundled <- list()
  for (i in 1:length(fits)){
      ffr.fit <- readRDS(fits[i])
    bundled[[i]] <- ffr.fit
  }
  return(bundled)
}
# ffr.fits <- bundle_fits('../../../results/R/OnePredOnePrey_fits/')


# Function to sort fits by magnitude of focal parameter point estimates
order.of.fits<-function(ffr.fits, 
                        order=FALSE, 
                        model=NULL, 
                        order.parm=NULL, 
                        point.est=c('median','mean')){
  point.est <- match.arg(point.est)
  point.est <- ifelse(point.est=='median', '50%', point.est)
  if(order){
    if(order.parm=='Sample size'){
      foc.parms <- unlist(lapply(ffr.fits, function(x) x$study.info$sample.size))
      how.to.order <- order(foc.parms)
    }else{
        foc.parms <- unlist(lapply(ffr.fits, function(x) x$estimates[[model]][point.est, order.parm, "estimate"]))
        how.to.order <- order(foc.parms)
      }
    }else{
      how.to.order <- 1:length(ffr.fits)
    }
}

# Function to plot focal parameter estimates and associated intervals across all fitted datasets.
plot.coefs <- function(
                ffr.fits=NULL,
                model=c('Holling.I',
                        'Holling.II',
                        'Beddington.DeAngelis',
                        'Crowley.Martin',
                        'Stouffer.Novak.I',
                        'Ratio',
                        'Arditi.Ginzburg',
                        'Hassell.Varley',
                        'Arditi.Akcakaya',
                        'Arditi.Akcakaya.Method.2'),
                parameter=c('attack',
                            'handling',
                            'interference',
                            'phi_denom',
                            'exponent'),  # add others later as needed
                ilink=identity,
                color.factor=c('None','Parasitoids','Replacement'),
                color.vector=NULL,
                pch.factor=c('None','Parasitoids','Replacement'),
                pch.vector=NULL,
                plot.SEs=FALSE,
                point.est=c('median','mean'), # ignored if plot.SEs=TRUE
                display.outlier.ests=FALSE,
                xlim=NULL,
                labels=NULL,
                vertLines=NULL,
                ... ){
  
  if(plot.SEs & is.null(ffr.fits[[1]]$profile)){
      stop('Fits must be profiled first to plot SEs.')
  }
  
  parameter <- match.arg(parameter)
  ilink <- match.fun(ilink)
  color.factor <- match.arg(color.factor)
    color.vector <- color.vector
  pch.factor <- match.arg(pch.factor)
    pch.vector <- pch.vector
  point.est <- match.arg(point.est)
    point.est <- ifelse(point.est=='median', '50%', point.est)

  if(is.null(xlim)){
    ests <- unlist(lapply(ffr.fits, function(x) x$estimates[[model]][point.est, parameter, "estimate"]))
    xlim <- range(ilink(ests))
  }
  
  # scaffold of a plot that doesn't actually show anything
  plot(
    y = 1:length(ffr.fits),
    x = 1:length(ffr.fits),
    type='n',
    yaxt='n',
    ylab='',
    xlim=xlim,
    ...
  )
  
  # tick marks and labels to indicate different data sets
  axis(side=2, at=1:length(ffr.fits), labels=labels, cex.axis=0.5, las=1)
  
  # mark where the existing models fall
  abline(v=vertLines, lty=2, col='grey')

  # plot these bad boys 
  for(i in 1:length(ffr.fits)){
    x <- ffr.fits[[i]]
    
    # color points depending on factor or vector of choice
    col <- 'black'
    if(!color.factor=='None'){
      if(color.factor=='Parasitoids' & !x$study.info$predator){
        col <- 'red'  }
      if(color.factor=='Replacement' & x$study.info$replacement){
        col <- 'red'  }
    }
    if(length(color.vector)==length(ffr.fits)){  # note that this overrides color.factor
      col <- color.vector[i]
    }
    
    # set pch of points depending on factor or vector of choice
    pch <- 19
    bg <- col
    if(!pch.factor=='None'){
      if(pch.factor=='Parasitoids' & !x$study.info$predator){
        pch <- 21
        bg <- 'white'
        }
      if(pch.factor=='Replacement' & x$study.info$replacement){
        pch <- 21
        bg <- 'white'
        }
    }
    if(length(pch.vector)==length(ffr.fits)){  # note that this overrides pch.factor
      pch <- pch.vector[i]
    }
    
    # extract point estimate (the median estimate is easy to determine regardless of the type of data so should be default)
    mm <- x$estimates[[model]][point.est, parameter, "estimate"]
    mm.link <- ilink(mm)
    
    # make all lines the equivalent for now
    lty <- "solid"

    # Function for number reformatting
    format.number <-function(number){
      if(number<0.001){
        result <- format(signif(number,3) , nsmall=0, scientific=TRUE)
      }else if(number<1){
        result <- format(round(number,3),nsmall = 3)
      }else if(number < 100){
        result <-  round(number, 2)
      }else{
        result <- format(signif(number,3) , nsmall=0, scientific=TRUE)
      }
      return(result)
    }
    
    # length of arrows to indicate values off the plot
    delta.arrow <- 0.02*diff(xlim)
    
    # if the point estimate is out of bounds don't even bother with its uncertainty
    if(mm.link < xlim[1] | mm.link > xlim[2]){
      if(mm.link > xlim[2]){
        arrows(xlim[2]-delta.arrow, i, par("usr")[2], i,
               length=0.05, col=col, lty=lty)
        if(display.outlier.ests){
            text(xlim[2]-delta.arrow, i, format.number(mm.link), 
                 pos=2, cex=0.7*par()$cex)
        }
      }else{
        arrows(xlim[1]+delta.arrow, i, par("usr")[1], i, 
               length=0.05, col=col, lty=lty)
        if(display.outlier.ests){
            text(xlim[1]+delta.arrow, i, format.number(mm.link), 
                 pos=4,cex=0.7*par()$cex)
        }
      }
    }else{
    
    if(plot.SEs){
      if(x$profile$method=='profile'){
        lty <- "solid" # best case is solid line
      }
      if(x$profile$method=='quadratic'){
        lty <- "dashed"  # quadratic approximation is dashed line
      }
      if(x$profile$method=='bootstrap'){
        lty <- "dotted"    # bootstrapped is dotted line
      }
      
 
      lb <- min(x$profile$cf[parameter,])
      ub <- max(x$profile$cf[parameter,])
      mm2 <- x$profile$cf[parameter,2]
      
      lb.link <- ilink(lb)
      ub.link <- ilink(ub)
      mm2.link <- ilink(mm2)
      
      # sometimes se is NA or we profile things but still get NA intervals, so stretch interval(s) to extremes of plot
      lb.link <- ifelse(is.na(lb.link), xlim[1], lb.link)
      ub.link <- ifelse(is.na(ub.link), xlim[2], ub.link)
      
      # For any of the above, don't plot off the figure
      lb.link <- ifelse(lb.link < xlim[1], xlim[1], lb.link)
      ub.link <- ifelse(ub.link > xlim[2], xlim[2], ub.link)
      
      
      if(mm.link > xlim[1] & mm.link < xlim[2]){
        # draw the error bars
        segments(lb.link, i, ub.link, i, col=col, lty=lty)
        
        # arrow up the limiting cases
        if(lb.link <= xlim[1] & parameter!='exponent'){
          arrows(xlim[1], i, par("usr")[1], i, 
                 length=0.05, col=col, lty=lty)
        }
        if(ub.link >= xlim[2]){
          arrows(xlim[2], i, par("usr")[2], i,
                 length=0.05, col=col, lty=lty)
        }
      }
    }
      # plot the actual estimate
      points(y=i, x=mm.link,
             col=col, pch=pch, bg=bg)
    
    }
    
  }
}