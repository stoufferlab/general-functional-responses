# needs the shape package
library(shape)

# Script to grab all the individually saved dataset fits (generated by 'fit_all_datasets.R') from a specified directory and return them as a bundled list object for subsequent profiling and plotting
bundle_fits <- function(dir){
  fits <- list.files(dir, 
                     pattern='.Rdata',
                     full.names=TRUE, 
                     include.dirs=FALSE)
  bundled <- list()
  for (i in 1:length(fits)){
      ffr.fit <- readRDS(fits[i])
    bundled[[i]] <- ffr.fit
  }
  return(bundled)
}

# Function to sort fits by magnitude of focal parameter point estimates
order.of.fits<-function(ffr.fits, 
                        order=FALSE, 
                        model=NULL, 
                        order.parm=NULL, 
                        point.est=c('median','mean')){
  point.est <- match.arg(point.est)
  point.est <- ifelse(point.est=='median', '50%', point.est)
  if(order){
    if(order.parm=='Sample size'){
      foc.parms <- unlist(lapply(ffr.fits, function(x) x$study.info$sample.size))
      how.to.order <- order(foc.parms)
    }else{
        foc.parms <- unlist(lapply(ffr.fits, function(x) x$estimates[[model]][point.est, order.parm, "estimate"]))
        how.to.order <- order(foc.parms)
      }
    }else{
      how.to.order <- 1:length(ffr.fits)
    }
}

# Function to plot focal parameter estimates and associated intervals across all fitted datasets.
plot.coefs <- function(
                ffr.fits=NULL,
                model=c('Holling.I',
                        'Holling.II',
                        'Beddington.DeAngelis',
                        'Crowley.Martin',
                        'Stouffer.Novak.I',
                        'Ratio',
                        'Arditi.Ginzburg',
                        'Hassell.Varley',
                        'Arditi.Akcakaya',
                        'Arditi.Akcakaya.Method.2'),
                parameter=c('attack',
                            'handling',
                            'interference',
                            'phi_denom',
                            'exponent',
                            'theta'),
                ilink=identity,
                color.factor=c('None','Parasitoids','Replacement'),
                color.vector=NULL,
                pch.factor=c('None','Parasitoids','Replacement'),
                pch.vector=NULL,
                plot.SEs=FALSE,
                SE.lty=NULL, # or vector of three lty options
                point.est=c('median','mean'), # ignored if plot.SEs=TRUE
                display.outlier.ests=FALSE,
                xlim=NULL,
                labels=NULL,
                vertLines=NULL,
                ...
){
  
  if(plot.SEs & is.null(ffr.fits[[1]]$profile)){
      stop('Fits must be profiled first to plot SEs.')
  }
  
  parameter <- match.arg(parameter)
  ilink <- match.fun(ilink)
  color.factor <- match.arg(color.factor)
  color.vector <- color.vector
  pch.factor <- match.arg(pch.factor)
  pch.vector <- pch.vector
  point.est <- match.arg(point.est)
  point.est <- ifelse(point.est=='median', '50%', point.est)

  if(is.null(xlim)){
    ests <- unlist(lapply(ffr.fits, function(x) x$estimates[[model]][point.est, parameter, "estimate"]))
    xlim <- range(ilink(ests))
  }
  
  # scaffold of a plot that doesn't actually show anything
  plot(
    y = 1:length(ffr.fits),
    x = 1:length(ffr.fits),
    type='n',
    yaxt='n',
    ylab='',
    xlim=xlim,
    axes=F,
    ...
  )

    # tick marks and labels to indicate different data sets
  axis(side=2, at=1:length(ffr.fits), labels=labels, cex.axis=0.45, las=1, lwd=0, lwd.ticks=1)
  axis(1, cex.axis=0.7, mgp=c(1.25,0,0), lwd=0, lwd.ticks=1)

  box(lwd=1)

  # mark where the existing models fall
  abline(v=vertLines, lty=2, col='grey')

  # plot these bad boys 
  for(i in 1:length(ffr.fits)){
    x <- ffr.fits[[i]]
    
    # color points depending on factor or vector of choice
    col <- 'black'
    if(!color.factor=='None'){
      if(color.factor=='Parasitoids' & !x$study.info$predator){
        col <- 'red'
      }
      if(color.factor=='Replacement' & x$study.info$replacement){
        col <- 'red'
      }
    }
    if(length(color.vector)==length(ffr.fits)){  # note that this overrides color.factor
      col <- color.vector[i]
    }
    
    # set pch of points depending on factor or vector of choice
    pch <- 21
    bg <- col
    if(!pch.factor=='None'){
      if(pch.factor=='Parasitoids' & !x$study.info$predator){
        pch <- 21
        bg <- 'white'
        }
      if(pch.factor=='Replacement' & x$study.info$replacement){
        pch <- 21
        bg <- 'white'
        }
    }
    if(length(pch.vector)==length(ffr.fits)){  # note that this overrides pch.factor
      pch <- pch.vector[i]
    }
    
    # extract point estimate (the median estimate is easy to determine regardless of the type of data so should be default)
    mm <- x$estimates[[model]][point.est, parameter, "estimate"]
    mm.link <- ilink(mm)
    
    # set SE line types
    if(is.null(SE.lty)){
      SE.lty <- rep(1,3)
    }

    # Function for number reformatting
    format.number <-function(number){
      if(number < -100){
        result <- format(signif(number,3), digits=3, nsmall=2, scientific=TRUE)
      }else if(number < -1){
        result <- format(round(number, 2), nsmall=2)
      }else if(number < -0.001){
        result <- format(signif(number,3), nsmall=0, scientific=TRUE)
      }else if(number < 0.001){
        result <- format(signif(number,3), nsmall=0, scientific=TRUE)
      }else if(number < 1){
        result <- format(round(number,3),nsmall = 3)
      }else if(number < 100){
        result <-  format(round(number, 2), nsmall=2)
      }else{ # > 100
        result <- format(signif(number,3) , nsmall=2, scientific=TRUE)
      }
      return(result)
    }
    
    # length of arrows to indicate values off the plot
    delta.arrow <- 0.04*diff(xlim)
  
    #extract the lower and upper bounds
    lb <- x$profile$cf[parameter,"lb"]
    ub <- x$profile$cf[parameter,"ub"]
    
    # use a link function 
    lb.link <- ilink(lb)
    ub.link <- ilink(ub)
    
    # sometimes se is NA or we profile things but still get NA intervals, so stretch interval(s) to extremes of plot
    lb.link <- ifelse(is.finite(lb.link), lb.link, xlim[1])
    ub.link <- ifelse(is.finite(ub.link), ub.link, xlim[2])
    
    # # For any of the above, don't plot off the figure
    # lb.link <- ifelse(lb.link < xlim[1], xlim[1], lb.link)
    # ub.link <- ifelse(ub.link > xlim[2], xlim[2], ub.link)

    # if the whole interval is out of bounds just add text
    lty <- SE.lty[1]
    # if(mm.link < xlim[1] | mm.link > xlim[2]){
      if(lb.link > xlim[2]){
        Arrows(
          xlim[2]-delta.arrow,
          i,
          xlim[2]+0.10,
          i,
          segment=FALSE,
          arr.type="triangle",
          arr.adj=1,
          arr.length=0.1,
          arr.width=0.075,
          arr.col=col,
          lcol=col,
          lty=lty
        )
        if(plot.SEs){
          if(x$profile$method=='profile'){
            lty <- SE.lty[1]
          }
          if(x$profile$method=='quadratic'){
            lty <- SE.lty[2]
          }
          if(x$profile$method=='bootstrap'){
            lty <- SE.lty[3]
          }
        }
        segments(
          xlim[2]-delta.arrow,
          i,
          xlim[2]+0.10,
          i,
          col=col,
          lty=lty
        )

        if(display.outlier.ests){
            text(xlim[2]-delta.arrow, i, format.number(mm.link), 
                 pos=2, cex=0.7*par()$cex)
        }
      }else if(ub.link < xlim[1]){
        Arrows(
          xlim[1]+delta.arrow,
          i,
          xlim[1]-0.10,
          i,
          segment=FALSE,
          arr.type="triangle",
          arr.adj=1,
          arr.length=0.1,
          arr.width=0.075,
          arr.col=col,
          lcol=col,
          lty=lty
        )
        if(plot.SEs){
          if(x$profile$method=='profile'){
            lty <- SE.lty[1]
          }
          if(x$profile$method=='quadratic'){
            lty <- SE.lty[2]
          }
          if(x$profile$method=='bootstrap'){
            lty <- SE.lty[3]
          }
        }
        segments(
          xlim[1]+delta.arrow,
          i,
          xlim[1]-0.10,
          i,
          col=col,
          lty=lty
        )
        if(display.outlier.ests){
            text(xlim[1]+delta.arrow, i, format.number(mm.link), 
                 pos=4,cex=0.7*par()$cex)
        }
      }else{
    
    if(plot.SEs){
      if(x$profile$method=='profile'){
        lty <- SE.lty[1]
      }
      if(x$profile$method=='quadratic'){
        lty <- SE.lty[2]
      }
      if(x$profile$method=='bootstrap'){
        lty <- SE.lty[3]
      }

      # if(mm.link > xlim[1] & mm.link < xlim[2]){
        # draw the error bars
        segments(
          max(lb.link,xlim[1]),
          i,
          min(ub.link,xlim[2]),
          i,
          col=col,
          lty=lty
        )
        
        # arrow up the limiting cases
        if(lb.link <= xlim[1] & parameter!='exponent'){
          Arrows(
            xlim[1],
            i,
            xlim[1]-0.10,
            i,
            segment=FALSE,
            arr.type="triangle",
            arr.adj=1,
            arr.length=0.1,
            arr.width=0.075,
            arr.col=col,
            lcol=col,
            lty=1
          )
        }
        if(ub.link >= xlim[2]){
          # Arrows(xlim[2], i, xlim[2]+0.10, i,
                 # arr.length=0.05, arr.col=col, lty=1)
          Arrows(
            xlim[2],
            i,
            xlim[2]+0.10,
            i,
            segment=FALSE,
            arr.type="triangle",
            arr.adj=1,
            arr.length=0.1,
            arr.width=0.075,
            arr.col=col,
            lcol=col,
            lty=1
          )
        }
      # }
    }
  }

    # plot the actual estimate
    par(xpd=TRUE)
    # plot the actual mean estimate
    if(mm.link > xlim[1] && mm.link < xlim[2]){
      points(
        y=i,
        x=mm.link,
        col=col,
        pch=pch,
        bg=bg
      )
    }else if(mm.link > xlim[2]){
      points(
        y=i,
        x=par("usr")[2],
        col=col,
        pch=pch,
        bg=bg
      )
    }else{
      points(
        y=i,
        x=par("usr")[1],
        col=col,
        pch=pch,
        bg=bg
      )
    }
    par(xpd=FALSE)
    
    
    
  }
}
