# Modified from 'plot_coefs()' in main 'lib' directory

# needs the shape package
library(shape)

# Script to grab all the individually saved dataset fits (generated by 'fit_all_datasets.R') from a specified directory and return them as a bundled list object for subsequent profiling and plotting
bundle_fits <- function(dir){
  fits <- list.files(dir, 
                     pattern='.Rdata',
                     full.names=TRUE, 
                     include.dirs=FALSE)
  bundled <- list()
  for (i in 1:length(fits)){
      ffr.fit <- readRDS(fits[i])
    bundled[[i]] <- ffr.fit
  }
  return(bundled)
}

# Function to sort fits by magnitude of focal parameter point estimates
order.of.fits <- function(ffr.fits, 
                          model = NULL, 
                          order.parm = NULL,
                          type = c('One_Predator_One_Prey',
                                   'One_Predator_Two_Prey'),
                          order = TRUE){
  type = match.arg(type)
  if(order){
    if(type =='One_Predator_One_Prey'){
      foc.parms <- unlist(lapply(ffr.fits, function(x){ 
        x$fits[[model]]$coefficients[order.parm] }))
    }
    if(type == 'One_Predator_Two_Prey'){
      foc.parms.prey1 <-
        unlist(lapply(ffr.fits, function(x){ 
          x$fits[[model]]$prey1$coefficients[order.parm] }))
      foc.parms.prey2 <-
        unlist(lapply(ffr.fits, function(x){ 
          x$fits[[model]]$prey2$coefficients[order.parm] }))
      # foc.parms <- apply(cbind(foc.parms.prey1, foc.parms.prey2), 1, mean)
      foc.parms <- apply(cbind(foc.parms.prey1, foc.parms.prey2), 1, max)
    }
    how.to.order <- order(foc.parms)
  }else{
      how.to.order <- 1:length(ffr.fits)
  }
  return(how.to.order)
}

# Function to plot focal parameter estimates and associated intervals across all fitted datasets.
plot.coefs <- function(
                ffr.fits = NULL,
                type = c('One_Predator_One_Prey',
                         'One_Predator_Two_Prey'),
                model = c('lm',
                          'lm.q',
                          'lm.main',
                          'lm.int',
                          'glm',
                          'glm.main',
                          'glm.int',
                        ),
                parameter = c('log.a.','a','b','c','d'),
                ilink = identity,
                bg.color.factor = c('None','Parasitoids','Replacement','Clarity'),
                bg.color.vector = NULL,
                pch.factor = c('None','Parasitoids','Replacement','Clarity'),
                pch.vector = NULL,
                p.level = 0.1,
                xlim = NULL,
                xlab = NULL,
                labels = NULL,
                add.nTrtmts = TRUE,
                vertLines = NULL,
                display.outlier.ests = TRUE,
                ...
){
  
  type <- match.arg(type)
  parameter <- match.arg(parameter)
  ilink <- match.fun(ilink)
  bg.color.factor <- match.arg(bg.color.factor)
  bg.color.vector <- bg.color.vector
  pch.factor <- match.arg(pch.factor)
  pch.vector <- pch.vector

  parm.pos <- c(1, 1, 2, 3, 3)[grep(parameter, c('log.a.','a','b','c','d'))]
  
  if(is.null(xlim)){
    if(type == 'One_Predator_One_Prey'){
      sumtabs <- lapply(ffr.fits, function(x){ summary(x$fits[[model]])$coefficients} )
    }
    if(type == 'One_Predator_Two_Prey'){
      sumtabs <- c(
        lapply(ffr.fits, function(x){ summary(x$fits[[model]]$prey1)$coefficients} ),
        lapply(ffr.fits, function(x){ summary(x$fits[[model]]$prey2)$coefficients} )
      )
    }
      ests <- unlist(lapply(sumtabs, function(x){ x[parm.pos, 1] }))
      lbs <- ests - unlist(lapply(sumtabs, function(x){ x[parm.pos, 2] }))
      ubs <- ests + unlist(lapply(sumtabs, function(x){ x[parm.pos, 2] }))
      xlim <- range(ilink(c(lbs, ubs)))
  }
  
  if(is.null(labels)){
    labels <- unlist(lapply(ffr.fits, function(x) x$study.info$datasetName))
    labels <- gsub('_', ' ', labels)
    if(add.nTrtmts){  # Add number of treatments to label?
      if(type == 'One_Predator_One_Prey'){
        labels <- paste0(labels,
                         ' (',
                         unlist(lapply(ffr.fits, function(x) x$study.info$nTrtmts))
                         ,')')
      }
      if(type == 'One_Predator_Two_Prey'){
        labels <- paste0(labels,
                         ' (',
                         unlist(lapply(ffr.fits, function(x) x$study.info$nTrtmts.Prey1)),
                         ',',
                         unlist(lapply(ffr.fits, function(x) x$study.info$nTrtmts.Prey2)),
                         ')')
      }
  }}
  
  if(is.null(xlab)){ xlab <- parameter }
  
  # scaffold of a plot that doesn't actually show anything
  plot(
    y = 1:length(ffr.fits),
    x = 1:length(ffr.fits),
    type='n',
    yaxt='n',
    ylab='',
    xlab=xlab,
    xlim=xlim,
    axes=F,
    ...
  )

    # tick marks and labels to indicate different data sets
  axis(side=2, at=1:length(ffr.fits), labels=labels, cex.axis=0.45, las=1, lwd=0, lwd.ticks=1)
  axis(1, cex.axis=0.7, mgp=c(1.25,0,0), tcl=-0.2, lwd=0, lwd.ticks=1)

  # jitter
  dy <- 0 # no change for One_Predator_One_Prey
  
  # alternating shade behind different studies
  if(type == 'One_Predator_Two_Prey'){
    
    dy <- 0.4 # jitter
    
    for(i in 1:length(ffr.fits)){
      if(i %% 2 == 0){
        polygon(c(-100,-100,100,100),c(i-0.5,i+0.5,i+0.5,i-0.5),col=grey(0.875),border=NA)
      }
    }
  }
  
  box(lwd=1)

  # mark where the existing models fall
  abline(v=vertLines, lty=3, col=grey(0.11))

  # plot these bad boys 
  for(i in 1:length(ffr.fits)){
    x <- ffr.fits[[i]]
    nP <- ifelse(type == 'One_Predator_One_Prey', 1, 2)

    for(p in 1:nP){
      # extract fit's summary table
      if(type == 'One_Predator_One_Prey'){
        sumtab <- summary(x$fits[[model]])$coefficients
      }
      if(type == 'One_Predator_Two_Prey'){
        sumtab <- summary(x$fits[[model]][[p]])$coefficients
      }
    # color points depending on factor or vector of choice
    bg <- 'black'
    if(!bg.color.factor=='None'){
      if(bg.color.factor=='Parasitoids' & !x$study.info$predator){
        bg <- 'white'
      }
      if(bg.color.factor=='Replacement' & x$study.info$replacement){
        bg <- 'white'
      }
      if(type == 'One_Predator_One_Prey'){
        if(bg.color.factor=='Clarity' & parameter=='b' & x$ttest[[model]] > p.level){
          bg <- 'white'
        }
      }
      if(type == 'One_Predator_Two_Prey'){
        if(bg.color.factor=='Clarity' & parameter=='b' & x$ttest[[model]][[p]] > p.level){
          bg <- 'white'
        }
      }
      if(bg.color.factor=='Clarity' & parameter!='b' & sumtab[parm.pos, 4] > p.level){
        bg <- 'white'
      }
    }
    if(length(bg.color.vector)==length(ffr.fits)){  # note that this overrides color.factor
      bg <- bg.color.vector[i]
    }
    
    # set pch of points depending on factor or vector of choice
    pch <- 21
    if(!pch.factor=='None'){
      if(pch.factor=='Parasitoids' & !x$study.info$predator){
        pch <- 23
        }
      if(pch.factor=='Replacement' & x$study.info$replacement){
        pch <- 23
      }
      if(type == 'One_Predator_One_Prey'){
        if(pch.factor=='Clarity' & parameter=='b' & x$ttest[[model]] > p.level){
          pch <- 23
        }
      }
      if(type == 'One_Predator_Two_Prey'){
        if(pch.factor=='Clarity' & parameter=='b' & x$ttest[[model]][[p]] > p.level){
          pch <- 23
        }
      }
      if(pch.factor=='Clarity' & parameter!='b' & sumtab[parm.pos, 4] > p.level){
        pch <- 23
      }
    }
    if(length(pch.vector)==length(ffr.fits)){  # note that this overrides pch.factor
      pch <- pch.vector[i]
    }
    
    mm <- sumtab[parm.pos, 1]
    mm.link <- ilink(mm)
    
    # Function for number reformatting
    format.number <-function(number){
      if(number < -100){
        result <- format(signif(number,3), digits=3, nsmall=2, scientific=TRUE)
      }else if(number < -1){
        result <- format(round(number, 2), nsmall=2)
      }else if(number < -0.001){
        result <- format(signif(number,3), nsmall=0, scientific=TRUE)
      }else if(number < 0.001){
        result <- format(signif(number,3), nsmall=0, scientific=TRUE)
      }else if(number < 1){
        result <- format(round(number,3),nsmall = 3)
      }else if(number < 100){
        result <-  format(round(number, 2), nsmall=2)
      }else{ # > 100
        result <- format(signif(number,3) , nsmall=2, scientific=TRUE)
      }
      return(result)
    }
    
    # length of arrows to indicate values off the plot
    delta.arrow <- 0.04*diff(xlim)
  
    # extract the lower and upper bounds
    lb <- sumtab[parm.pos, 1] - sumtab[parm.pos, 2]
    ub <- sumtab[parm.pos, 1] + sumtab[parm.pos, 2]
    
    # use a link function 
    lb.link <- ilink(lb)
    ub.link <- ilink(ub)
    
    # sometimes se is NA or we profile things but still get NA intervals, so stretch interval(s) to extremes of plot
    lb.link <- ifelse(is.finite(lb.link), lb.link, xlim[1])
    ub.link <- ifelse(is.finite(ub.link), ub.link, xlim[2])
    

    # if the whole interval is out of bounds just add text
    lty <- 1
    col <- 'black'
      if(lb.link > xlim[2]){
        Arrows(
          xlim[2]-delta.arrow,
          i+dy*(p-1.5),
          xlim[2]+0.10,
          i+dy*(p-1.5),
          segment=FALSE,
          arr.type="triangle",
          arr.adj=1,
          arr.length=0.1,
          arr.width=0.075,
          arr.col=col,
          lcol=col,
          lty=lty
        )
        segments(
          xlim[2]-delta.arrow,
          i+dy*(p-1.5),
          xlim[2]+0.10,
          i+dy*(p-1.5),
          col=col,
          lty=lty
        )

        if(display.outlier.ests){
            text(xlim[2]-delta.arrow, i+dy*(p-1.5), 
                 format.number(mm.link), 
                 pos=2, cex=0.7*par()$cex)
        }
      }else if(ub.link < xlim[1]){
        Arrows(
          xlim[1]+delta.arrow,
          i+dy*(p-1.5),
          xlim[1]-0.10,
          i+dy*(p-1.5),
          segment=FALSE,
          arr.type="triangle",
          arr.adj=1,
          arr.length=0.1,
          arr.width=0.075,
          arr.col=col,
          lcol=col,
          lty=lty
        )
        segments(
          xlim[1]+delta.arrow,
          i+dy*(p-1.5),
          xlim[1]-0.10,
          i+dy*(p-1.5),
          col=col,
          lty=lty
        )
        if(display.outlier.ests){
            text(xlim[1]+delta.arrow, i+dy*(p-1.5), 
                 format.number(mm.link), 
                 pos=4,cex=0.7*par()$cex)
        }
      }else{

        # draw the error bars
        segments(
          max(lb.link,xlim[1]),
          i+dy*(p-1.5),
          min(ub.link,xlim[2]),
          i+dy*(p-1.5),
          col=col,
          lty=lty
        )
        
        # arrow up the limiting cases
        if(lb.link <= xlim[1]){
          Arrows(
            xlim[1],
            i+dy*(p-1.5),
            xlim[1]-0.10,
            i+dy*(p-1.5),
            segment=FALSE,
            arr.type="triangle",
            arr.adj=1,
            arr.length=0.1,
            arr.width=0.075,
            arr.col=col,
            lcol=col,
            lty=1
          )
        }
        if(ub.link >= xlim[2]){
          # Arrows(xlim[2], i+dy*(p-1.5), xlim[2]+0.10, i+dy*(p-1.5),
                 # arr.length=0.05, arr.col=col, lty=1)
          Arrows(
            xlim[2],
            i+dy*(p-1.5),
            xlim[2]+0.10,
            i+dy*(p-1.5),
            segment=FALSE,
            arr.type="triangle",
            arr.adj=1,
            arr.length=0.1,
            arr.width=0.075,
            arr.col=col,
            lcol=col,
            lty=1
          )
        }
      }

    # plot the actual estimate
    par(xpd=TRUE)
    # plot the actual mean estimate
    if(mm.link > xlim[1] && mm.link < xlim[2]){
      points(
        y=i+dy*(p-1.5),
        x=mm.link,
        col=col,
        pch=pch,
        bg=bg
      )
    }else if(mm.link > xlim[2]){
      points(
        y=i+dy*(p-1.5),
        x=par("usr")[2],
        col=col,
        pch=pch,
        bg=bg
      )
    }else{
      points(
        y=i+dy*(p-1.5),
        x=par("usr")[1],
        col=col,
        pch=pch,
        bg=bg
      )
    }
    par(xpd=FALSE)
  } # end of prey1 prey2 loop
  }
}
